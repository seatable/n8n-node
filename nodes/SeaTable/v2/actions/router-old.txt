
import FormData from 'form-data';

import * as row from './row';
import * as base from './base';

import type {
	ICtx,
	IRow,
	IRowObject,
	IRowResponse,
	IDtableMetadataColumn,
	ICollaboratorsResult,
	ICollaborator,
	IUploadLink,
	SeaTable,
} from './Interfaces';

import {
	getTableColumns,
	rowExport,
	rowFormatColumns,
	rowMapKeyToName,
	seaTableApiRequest,
	split,
	updateAble,
	enrichColumns,
	simplify_new,
} from '../GenericFunctions';

import type { TColumnsUiValues, TColumnValue } from '../types';
//import { response } from 'express';


/*
	
	} else if (operation === 'getPublicURL') {
		// ----------------------------------
		//         row:getPublicURL
		// ----------------------------------

		const assetPath = this.getNodeParameter('assetPath', 0) as string;
		console.log(assetPath);

		for (let i = 0; i < items.length; i++) {
			try {
				const response = (await seaTableApiRequest.call(
					this,
					ctx,
					'GET',
					`/api/v2.1/dtable/app-download-link/?path=${assetPath}`,
				)) as IDataObject;

				/*
                let response2 = await seaTableApiRequest.call(
                    this,
                    ctx,
                    'GET',
                    response.download_link.split('https://stage.seatable.io')[1],
                );
                */

				/* das hat alles nicht funktioniert 
                        //console.log(response2);

                        //console.log(response.download_link.split('https://stage.seatable.io')[1]);
                        //console.log('RESPINSE- getpublicurl');
                        // console.log(response2); // das ist komischer stream          �e`���Ϭ�OY^����SAAR�A�,\O5�f�!�3�v�t��R�Z�?��[��0=�|@n��PM_A�~�\�J0�9)X;��4�L3q\C  ���i܋���(Z#����$P

                        //console.log(response2);

                        //const fs = require('fs'); // If working in Node.js
                        //const fileType = require('file-type');

                        // Read the binary data from a file (replace 'filename' with your file path)
                        //const data = fs.readFileSync('filename');

                        // Attempt to identify the file type
                        //const result2 = fileType(response2);
                        //console.log(result2);

                        console.log('neuer versuch');
                        const base64String = response2.toString('base64');
                        console.log(base64String);
                        console.log('neuer versuche ende');

                        //console.log('BUFFER');
                        //console.log(Buffer.from(response2));

                        //let binaryString = String.fromCharCode.apply(null, Buffer.from(response2));
                        //let xxx2 = binaryString.toString('base64')
                        //console.log('TEST');
                        //console.log(binaryString);

                        //console.log('BASE64');
                        let xxx = Buffer.from(response2).toString('base64');
                        console.log(xxx);

                        items[i].binary![dataPropertyNameDownload] = await this.nodeHelpers.copyBinaryFile(
                            binaryFile.path,
                            basename(remoteFilePath),
                        );

                        let fileName = 'test.png';
                        let response3 = await this.helpers.copyBinaryFile(response2, fileName as string);
                        console.log(response3);

                        //console.log(response);
                        //console.log(response2);
                        */

				/* so geht es nur mit svg 
                const binary: IBinaryKeyData = {};
                binary!['data'] = await this.helpers.prepareBinaryData(
                    Buffer.from(response2),
                    assetPath,
                    mime.lookup(assetPath),
                );
                console.log(binary);
            
                const json = { response };
                const result: INodeExecutionData = {
                    json,
                    binary,
                };
                */

				const executionData = this.helpers.constructExecutionMetaData(
					this.helpers.returnJsonArray(response),
					{ itemData: { item: i } },
				);

				returnData.push(...executionData);
			} catch (error) {
				if (this.continueOnFail()) {
					const executionErrorData = this.helpers.constructExecutionMetaData(
						this.helpers.returnJsonArray({ error: error.message }),
						{ itemData: { item: i } },
					);
					returnData.push(...executionErrorData);
					continue;
				}
				throw error;
			}
		}
	} 
	} else if (operation === 'upload') {
		// ----------------------------------
		//         row:upload
		// ----------------------------------

		const tableName = this.getNodeParameter('tableName', 0) as string;
		// e.g. Employees:::000 (source table name:::source table id)
		const uploadColumn = this.getNodeParameter('uploadColumn', 0) as any;
		// e.g. Link to other records:::a0UG:::8qE7 (column name:::link_id:::other table id)

		const uploadColumnType = uploadColumn.split(':::')[1];

		//const method = operation === 'addLink' ? 'POST' : 'DELETE';

		let uploadLink = (await seaTableApiRequest.call(
			this,
			ctx,
			'GET',
			'/api/v2.1/dtable/app-upload-link/',
		)) as IUploadLink;

		for (let i = 0; i < items.length; i++) {
			try {
				const dataPropertyName = this.getNodeParameter('dataPropertyName', i) as string;
				const rowId = this.getNodeParameter('rowId', i) as string;

				const binaryData = this.helpers.assertBinaryData(i, dataPropertyName);
				//console.log('BINARYDATA');
				//console.log(binaryData);

				// das enthält das bild in base64!
				// console.log(binaryData.data);

				// warum brauche ich diesen buffer??
				//let binaryData2 = await this.helpers.getBinaryDataBuffer(i, dataPropertyName);
				//console.log(binaryData2);
				/*
                Buffer(358013) [Uint8Array] [
                    137,  80,  78, 71,  13,  10,  26,  10,   0,   0,   0,  13,
                        73,  72,  68, 82,   0,   0,   1, 206,   0,   0,   2,  27,
                        8,   6,   0,  0,   0,  98, 253, 126, 177,   0,   0,  32,
                        0,  73,  68, 65,  84, 120,  94, 180, 189, 105, 175, 109,
                        91, 146,  29, 20, 187,  61, 237, 237, 222, 203, 151,  77,
                    117, 166, 176,  1, 137, 111, 252,  27,  84, 126, 165,  74,
                    217, 178, 133, 45, 140, 108, 144,  42, 141, 133, 193,  52,
                        2, 132,  16, 66,  66,   8,   9, 137,  63, 197,  23, 196,
                        7,  35,  33, 55,
                    ... 357913 more items
                    ]
                */

				// das habe ich doch schon in binarydata
				//let test = await this.helpers.prepareBinaryData(binaryData2, 'bogdan.png', 'image/png');
				//console.log(test);

				const { Readable } = require('stream');
				const decodedData = Buffer.from(binaryData.data, 'base64');
				const stream = Readable.from(decodedData);
				//console.log(stream);

				//const stream = Readable.from(binaryData.data);
				// ?? hmm...

				const formData = new FormData();
				formData.append('parent_dir', uploadLink.parent_path);
				formData.append('replace', '0');
				formData.append(
					'relative_path',
					uploadColumnType === 'image'
						? uploadLink.img_relative_path
						: uploadLink.file_relative_path,
				);
				formData.append('file', stream, binaryData.fileName);
				//console.log(formData);

				//stream.resume(); // so bei zapier??

				//this.helpers.request('https://stage.seatable.io/seafhttp/upload-api/68ecfe7e-174f-425a-ace8-4e32c3be29e0?ret-json=1', options)

				console.log('send file to seatable');
				let uploadAsset = await seaTableApiRequest.call(
					this,
					ctx,
					'POST',
					'/seafhttp/upload-api/' +
						uploadLink.upload_link.split('seafhttp/upload-api/')[1] +
						'?ret-json=true',
					formData,
				);
				//console.log('error');
				//console.log(uploadAsset);

				const executionData = this.helpers.constructExecutionMetaData(
					this.helpers.returnJsonArray(uploadAsset),
					{ itemData: { item: i } },
				);

				returnData.push(...executionData);
			} catch (error) {
				if (this.continueOnFail()) {
					const executionErrorData = this.helpers.constructExecutionMetaData(
						this.helpers.returnJsonArray({ error: error.message }),
						{ itemData: { item: i } },
					);
					returnData.push(...executionErrorData);
				}
				throw error;
			}
		}
	} 
	return [returnData];
}
